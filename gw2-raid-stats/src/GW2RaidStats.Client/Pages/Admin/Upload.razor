@page "/admin/upload"
@inject HttpClient Http
@inject ISnackbar Snackbar

<PageTitle>GW2 Raid Stats - Upload Logs</PageTitle>

<AdminAuth>
<MudText Typo="Typo.h4" Class="mb-4">Upload Logs</MudText>

@* Raw Log Upload Section (Primary) *@
<MudPaper Class="pa-4 mb-4" Elevation="2">
    <MudText Typo="Typo.h6" Class="mb-3">
        <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Class="mr-2" />
        Upload Raw Logs (.zevtc / .evtc)
    </MudText>
    <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pt-4">
        <MudTabPanel Text="Browser Upload" Icon="@Icons.Material.Filled.CloudUpload">
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mb-4">
                Upload raw ArcDPS log files from your browser. Files are uploaded in batches to avoid memory issues.
            </MudText>

            <MudStack Row="true" Spacing="2" Class="mb-4">
                <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                               Accept=".zevtc,.evtc"
                               MaximumFileCount="100"
                               FilesChanged="OnRawFilesSelected">
                    <ActivatorContent>
                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.AttachFile"
                                   Disabled="@_isUploadingRaw">
                            Select Files (max 100)
                        </MudButton>
                    </ActivatorContent>
                </MudFileUpload>
            </MudStack>

            @if (_selectedRawFiles.Count > 0)
            {
                <MudText Typo="Typo.body2" Class="mb-2">
                    @_selectedRawFiles.Count file(s) selected (@FormatFileSize(_selectedRawFiles.Sum(f => f.Size)))
                </MudText>

                <MudButton Variant="Variant.Filled"
                           Color="Color.Secondary"
                           StartIcon="@Icons.Material.Filled.Upload"
                           OnClick="UploadRawFilesBatched"
                           Disabled="@_isUploadingRaw"
                           Class="mb-4">
                    @if (_isUploadingRaw)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <span>Uploading...</span>
                    }
                    else
                    {
                        <span>Upload for Processing</span>
                    }
                </MudButton>
            }

            @if (_rawUploadProgress != null && _isUploadingRaw)
            {
                <MudPaper Class="pa-3 mb-3" Elevation="0" Style="background-color: var(--mud-palette-background-grey);">
                    <MudText Typo="Typo.body2" Class="mb-2">
                        Uploading batch @_rawUploadProgress.CurrentBatch of @_rawUploadProgress.TotalBatches
                    </MudText>
                    <MudProgressLinear Color="Color.Primary" Value="@_rawUploadProgress.PercentComplete" Class="mb-2" />
                    <MudText Typo="Typo.caption">
                        @_rawUploadProgress.FilesUploaded / @_rawUploadProgress.TotalFiles files uploaded
                    </MudText>
                </MudPaper>
            }

            @if (_rawUploadResult != null)
            {
                <MudAlert Severity="@(_rawUploadResult.Rejected > 0 ? Severity.Warning : Severity.Success)" Class="mt-3">
                    @_rawUploadResult.Accepted files queued for processing.
                    @if (_rawUploadResult.Rejected > 0)
                    {
                        <span> @_rawUploadResult.Rejected files rejected.</span>
                    }
                </MudAlert>
                @if (_rawUploadResult.Errors.Count > 0 && _rawUploadResult.Errors.Count <= 20)
                {
                    <MudList T="string" Dense="true" Class="mt-2">
                        @foreach (var error in _rawUploadResult.Errors)
                        {
                            <MudListItem Icon="@Icons.Material.Filled.Error" IconColor="Color.Error">
                                <MudText Typo="Typo.caption">@error</MudText>
                            </MudListItem>
                        }
                    </MudList>
                }
                else if (_rawUploadResult.Errors.Count > 20)
                {
                    <MudText Typo="Typo.caption" Color="Color.Error" Class="mt-2">
                        @_rawUploadResult.Errors.Count errors (showing first 20)
                    </MudText>
                }
            }
        </MudTabPanel>

        <MudTabPanel Text="Server Directory Scan" Icon="@Icons.Material.Filled.FolderOpen">
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mb-4">
                Scan a directory on the server for log files. Ideal for large imports - just copy your logs folder to the server
                and provide the path. Files will be copied to the processing queue.
            </MudText>

            <MudTextField @bind-Value="_rawSourceDirectory"
                          Label="Source Directory Path"
                          Placeholder="/path/to/your/arcdps/logs"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.FolderOpen"
                          HelperText="Path on the server where your .zevtc files are located"
                          Class="mb-3"
                          Disabled="@_isScanningDirectory" />

            <MudCheckBox @bind-Value="_scanRecursively" Label="Include subfolders" Class="mb-3" Disabled="@_isScanningDirectory" />

            <MudButton Variant="Variant.Filled"
                       Color="Color.Secondary"
                       StartIcon="@Icons.Material.Filled.Search"
                       OnClick="ScanServerDirectory"
                       Disabled="@(_isScanningDirectory || string.IsNullOrWhiteSpace(_rawSourceDirectory))"
                       Class="mb-4">
                @if (_isScanningDirectory)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Scanning...</span>
                }
                else
                {
                    <span>Scan & Queue Files</span>
                }
            </MudButton>

            @if (_directoryScanResult != null)
            {
                <MudAlert Severity="@(_directoryScanResult.Failed > 0 ? Severity.Warning : Severity.Success)" Class="mt-3">
                    Found @_directoryScanResult.Found files. @_directoryScanResult.Queued queued for processing.
                    @if (_directoryScanResult.Skipped > 0)
                    {
                        <span> @_directoryScanResult.Skipped already processed.</span>
                    }
                    @if (_directoryScanResult.Failed > 0)
                    {
                        <span> @_directoryScanResult.Failed failed.</span>
                    }
                </MudAlert>
            }
        </MudTabPanel>
    </MudTabs>
</MudPaper>

@* Processing Queue Status *@
<MudPaper Class="pa-4 mb-4" Elevation="2">
    <MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-3">
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.Queue" Class="mr-2" />
            Processing Queue
        </MudText>
        <MudSpacer />
        <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="RefreshQueueStatus" Disabled="@_isLoadingQueue" />
    </MudStack>

    @if (_queueStatus != null)
    {
        <MudGrid>
            <MudItem xs="4">
                <MudCard Elevation="0" Style="background-color: var(--mud-palette-info-lighten);">
                    <MudCardContent Class="text-center pa-2">
                        <MudText Typo="Typo.h5" Color="Color.Info">@_queueStatus.PendingCount</MudText>
                        <MudText Typo="Typo.caption">Pending</MudText>
                    </MudCardContent>
                </MudCard>
            </MudItem>
            <MudItem xs="4">
                <MudCard Elevation="0" Style="background-color: var(--mud-palette-warning-lighten);">
                    <MudCardContent Class="text-center pa-2">
                        <MudText Typo="Typo.h5" Color="Color.Warning">@_queueStatus.ProcessingCount</MudText>
                        <MudText Typo="Typo.caption">Processing</MudText>
                    </MudCardContent>
                </MudCard>
            </MudItem>
            <MudItem xs="4">
                <MudCard Elevation="0" Style="background-color: var(--mud-palette-error-lighten);">
                    <MudCardContent Class="text-center pa-2">
                        <MudText Typo="Typo.h5" Color="Color.Error">@_queueStatus.FailedCount</MudText>
                        <MudText Typo="Typo.caption">Failed</MudText>
                    </MudCardContent>
                </MudCard>
            </MudItem>
        </MudGrid>

        @if (_queueStatus.ProcessingFiles.Count > 0)
        {
            <MudText Typo="Typo.body2" Class="mt-3 mb-1">Currently Processing:</MudText>
            @foreach (var file in _queueStatus.ProcessingFiles)
            {
                <MudChip T="string" Size="Size.Small" Color="Color.Warning" Class="mr-1">@file</MudChip>
            }
        }
    }
    else
    {
        <MudText Typo="Typo.body2" Color="Color.Default">Loading queue status...</MudText>
    }
</MudPaper>

@* Discord Notification Section *@
<MudPaper Class="pa-4 mb-4" Elevation="2">
    <MudText Typo="Typo.h6" Class="mb-3">
        <MudIcon Icon="@Icons.Material.Filled.Campaign" Class="mr-2" />
        Discord Notifications
    </MudText>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-3">
        Post a summary of the most recent raid session to your Discord notification channel.
    </MudText>
    <MudButton Variant="Variant.Filled" Color="Color.Primary"
               Disabled="@_postingSession"
               OnClick="PostSessionSummary"
               StartIcon="@Icons.Material.Filled.Send">
        @if (_postingSession)
        {
            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
        }
        Post Session Summary to Discord
    </MudButton>
</MudPaper>

<MudDivider Class="my-4" />
<MudText Typo="Typo.h5" Class="mb-4">Legacy Import (Pre-parsed JSON)</MudText>

<MudGrid>
    @* File Upload Section *@
    <MudItem xs="12" md="6">
        <MudPaper Class="pa-4" Elevation="2">
            <MudText Typo="Typo.h6" Class="mb-3">
                <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Class="mr-2" />
                Upload JSON Files
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mb-4">
                Upload Elite Insights JSON log files directly from your browser.
            </MudText>

            <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                           Accept=".json"
                           MaximumFileCount="500"
                           FilesChanged="OnFilesSelected"
                           Class="mb-4">
                <ActivatorContent>
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               StartIcon="@Icons.Material.Filled.AttachFile"
                               Disabled="@_isUploading">
                        Select Files
                    </MudButton>
                </ActivatorContent>
            </MudFileUpload>

            @if (_selectedFiles.Count > 0)
            {
                <MudText Typo="Typo.body2" Class="mb-2">
                    @_selectedFiles.Count file(s) selected
                </MudText>

                <MudSlider @bind-Value="_uploadParallelism"
                           Min="1"
                           Max="8"
                           Step="1"
                           Color="Color.Primary"
                           Class="mb-3"
                           Disabled="@_isUploading">
                    Parallel uploads: @_uploadParallelism
                </MudSlider>

                <MudButton Variant="Variant.Filled"
                           Color="Color.Secondary"
                           StartIcon="@Icons.Material.Filled.Upload"
                           OnClick="UploadFilesParallel"
                           Disabled="@_isUploading"
                           Class="mb-4">
                    @if (_isUploading)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <span>Uploading...</span>
                    }
                    else
                    {
                        <span>Upload</span>
                    }
                </MudButton>
            }
        </MudPaper>
    </MudItem>

    @* Directory Import Section *@
    <MudItem xs="12" md="6">
        <MudPaper Class="pa-4" Elevation="2">
            <MudText Typo="Typo.h6" Class="mb-3">
                <MudIcon Icon="@Icons.Material.Filled.Folder" Class="mr-2" />
                Bulk Import from Directory (Server)
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mb-4">
                Import all JSON files from a directory on the server. Ideal for large batch imports.
            </MudText>

            <MudTextField @bind-Value="_sourceDirectory"
                          Label="Source Directory"
                          Placeholder="/path/to/logs"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.FolderOpen"
                          Class="mb-3"
                          Disabled="@_isImporting" />

            <MudTextField @bind-Value="_completedDirectory"
                          Label="Completed Directory (optional)"
                          Placeholder="/path/to/completed"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.CheckCircle"
                          HelperText="Successfully imported files will be moved here"
                          Class="mb-3"
                          Disabled="@_isImporting" />

            <MudTextField @bind-Value="_failedDirectory"
                          Label="Failed Directory (optional)"
                          Placeholder="/path/to/failed"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Error"
                          HelperText="Failed files will be moved here"
                          Class="mb-3"
                          Disabled="@_isImporting" />

            <MudSlider @bind-Value="_parallelism"
                       Min="1"
                       Max="16"
                       Step="1"
                       Color="Color.Primary"
                       Class="mb-3"
                       Disabled="@_isImporting">
                Parallelism: @_parallelism threads
            </MudSlider>

            <MudButton Variant="Variant.Filled"
                       Color="Color.Secondary"
                       StartIcon="@Icons.Material.Filled.PlayArrow"
                       OnClick="StartDirectoryImport"
                       Disabled="@(_isImporting || string.IsNullOrWhiteSpace(_sourceDirectory))">
                @if (_isImporting)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Importing...</span>
                }
                else
                {
                    <span>Start Import</span>
                }
            </MudButton>
        </MudPaper>
    </MudItem>
</MudGrid>

@* Upload Progress Section *@
@if (_isUploading && _fileProgress.Count > 0)
{
    <MudPaper Class="pa-4 mt-4" Elevation="2">
        <MudText Typo="Typo.h6" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Class="mr-2" />
            Upload Progress
        </MudText>

        <MudGrid Class="mb-4">
            <MudItem xs="3">
                <MudText Typo="Typo.body2" Align="Align.Center">
                    <MudIcon Icon="@Icons.Material.Filled.HourglassEmpty" Size="Size.Small" Class="mr-1" />
                    Pending: @_fileProgress.Count(f => f.Value.Status == UploadStatus.Pending)
                </MudText>
            </MudItem>
            <MudItem xs="3">
                <MudText Typo="Typo.body2" Align="Align.Center" Color="Color.Info">
                    <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Size="Size.Small" Class="mr-1" />
                    Uploading: @_fileProgress.Count(f => f.Value.Status == UploadStatus.Uploading)
                </MudText>
            </MudItem>
            <MudItem xs="3">
                <MudText Typo="Typo.body2" Align="Align.Center" Color="Color.Success">
                    <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Class="mr-1" />
                    Done: @_fileProgress.Count(f => f.Value.Status == UploadStatus.Completed)
                </MudText>
            </MudItem>
            <MudItem xs="3">
                <MudText Typo="Typo.body2" Align="Align.Center" Color="Color.Error">
                    <MudIcon Icon="@Icons.Material.Filled.Error" Size="Size.Small" Class="mr-1" />
                    Failed: @_fileProgress.Count(f => f.Value.Status == UploadStatus.Failed)
                </MudText>
            </MudItem>
        </MudGrid>

        @{
            var completed = _fileProgress.Count(f => f.Value.Status == UploadStatus.Completed || f.Value.Status == UploadStatus.Failed);
            var total = _fileProgress.Count;
            var percent = total > 0 ? (double)completed / total * 100 : 0;
        }
        <MudProgressLinear Color="Color.Primary" Value="@percent" Class="mb-2" />
        <MudText Typo="Typo.body2" Class="mb-4">@completed / @total files processed</MudText>

        <MudExpansionPanels>
            <MudExpansionPanel Text="File Details" Expanded="false">
                <div style="max-height: 300px; overflow-y: auto;">
                    <MudSimpleTable Dense="true" Striped="true">
                        <thead>
                            <tr>
                                <th>File</th>
                                <th style="width: 120px;">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var kvp in _fileProgress.OrderBy(f => f.Value.Status == UploadStatus.Completed ? 2 : f.Value.Status == UploadStatus.Failed ? 3 : f.Value.Status == UploadStatus.Uploading ? 0 : 1))
                            {
                                <tr>
                                    <td style="max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                        @kvp.Key
                                    </td>
                                    <td>
                                        @switch (kvp.Value.Status)
                                        {
                                            case UploadStatus.Pending:
                                                <MudChip T="string" Size="Size.Small" Color="Color.Default">Pending</MudChip>
                                                break;
                                            case UploadStatus.Uploading:
                                                <MudChip T="string" Size="Size.Small" Color="Color.Info">
                                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Style="width: 14px; height: 14px;" Class="mr-1" />
                                                    Uploading
                                                </MudChip>
                                                break;
                                            case UploadStatus.Completed:
                                                @if (kvp.Value.WasDuplicate)
                                                {
                                                    <MudChip T="string" Size="Size.Small" Color="Color.Warning">Duplicate</MudChip>
                                                }
                                                else
                                                {
                                                    <MudChip T="string" Size="Size.Small" Color="Color.Success">Imported</MudChip>
                                                }
                                                break;
                                            case UploadStatus.Failed:
                                                <MudTooltip Text="@kvp.Value.Error">
                                                    <MudChip T="string" Size="Size.Small" Color="Color.Error">Failed</MudChip>
                                                </MudTooltip>
                                                break;
                                        }
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </MudSimpleTable>
                </div>
            </MudExpansionPanel>
        </MudExpansionPanels>
    </MudPaper>
}

@* Directory Import Progress Section *@
@if (_isImporting)
{
    <MudPaper Class="pa-4 mt-4" Elevation="2">
        <MudText Typo="Typo.h6" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.Sync" Class="mr-2 mud-icon-spin" />
            Import Progress
        </MudText>
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-2" />
        <MudText Typo="Typo.body2">Processing files... Please wait.</MudText>
    </MudPaper>
}

@* Results Section *@
@if (_bulkResult != null)
{
    <MudPaper Class="pa-4 mt-4" Elevation="2">
        <MudText Typo="Typo.h6" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.Assessment" Class="mr-2" />
            Import Results
        </MudText>

        <MudGrid Class="mb-4">
            <MudItem xs="6" sm="3">
                <MudCard Elevation="0" Style="background-color: var(--mud-palette-background-grey);">
                    <MudCardContent Class="text-center">
                        <MudText Typo="Typo.h4">@_bulkResult.TotalFiles</MudText>
                        <MudText Typo="Typo.caption">Total Files</MudText>
                    </MudCardContent>
                </MudCard>
            </MudItem>
            <MudItem xs="6" sm="3">
                <MudCard Elevation="0" Style="background-color: var(--mud-palette-success-lighten);">
                    <MudCardContent Class="text-center">
                        <MudText Typo="Typo.h4" Color="Color.Success">@_bulkResult.Imported</MudText>
                        <MudText Typo="Typo.caption">Imported</MudText>
                    </MudCardContent>
                </MudCard>
            </MudItem>
            <MudItem xs="6" sm="3">
                <MudCard Elevation="0" Style="background-color: var(--mud-palette-warning-lighten);">
                    <MudCardContent Class="text-center">
                        <MudText Typo="Typo.h4" Color="Color.Warning">@_bulkResult.Duplicates</MudText>
                        <MudText Typo="Typo.caption">Duplicates</MudText>
                    </MudCardContent>
                </MudCard>
            </MudItem>
            <MudItem xs="6" sm="3">
                <MudCard Elevation="0" Style="background-color: var(--mud-palette-error-lighten);">
                    <MudCardContent Class="text-center">
                        <MudText Typo="Typo.h4" Color="Color.Error">@_bulkResult.Failed</MudText>
                        <MudText Typo="Typo.caption">Failed</MudText>
                    </MudCardContent>
                </MudCard>
            </MudItem>
        </MudGrid>

        <MudText Typo="Typo.body2" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.Timer" Size="Size.Small" Class="mr-1" />
            Completed in @_bulkResult.Duration.TotalSeconds.ToString("F1") seconds
        </MudText>

        @if (_bulkResult.Results.Any(r => !r.Success))
        {
            <MudExpansionPanels Class="mt-3">
                <MudExpansionPanel Text="@($"Failed Files ({_bulkResult.Results.Count(r => !r.Success)})")">
                    <MudList T="string" Dense="true">
                        @foreach (var result in _bulkResult.Results.Where(r => !r.Success))
                        {
                            <MudListItem Icon="@Icons.Material.Filled.Error" IconColor="Color.Error">
                                <MudText Typo="Typo.body2">@result.FileName</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Error">@result.Error</MudText>
                            </MudListItem>
                        }
                    </MudList>
                </MudExpansionPanel>
            </MudExpansionPanels>
        }
    </MudPaper>
}

@if (_uploadResults.Count > 0)
{
    <MudPaper Class="pa-4 mt-4" Elevation="2">
        <MudText Typo="Typo.h6" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.CloudDone" Class="mr-2" />
            Upload Results
        </MudText>

        <MudSimpleTable Dense="true" Striped="true">
            <thead>
                <tr>
                    <th>File</th>
                    <th>Boss</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var result in _uploadResults)
                {
                    <tr>
                        <td>@result.FileName</td>
                        <td>@(result.BossName ?? "-")</td>
                        <td>
                            @if (result.Success)
                            {
                                if (result.WasDuplicate)
                                {
                                    <MudChip T="string" Color="Color.Warning" Size="Size.Small">Duplicate</MudChip>
                                }
                                else
                                {
                                    <MudChip T="string" Color="Color.Success" Size="Size.Small">Imported</MudChip>
                                }
                            }
                            else
                            {
                                <MudTooltip Text="@result.Error">
                                    <MudChip T="string" Color="Color.Error" Size="Size.Small">Failed</MudChip>
                                </MudTooltip>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </MudSimpleTable>
    </MudPaper>
}
</AdminAuth>

@code {
    private List<IBrowserFile> _selectedFiles = new();
    private bool _isUploading;
    private bool _isImporting;
    private bool _postingSession;
    private List<ImportResult> _uploadResults = new();
    private BulkImportResult? _bulkResult;
    private Dictionary<string, FileUploadProgress> _fileProgress = new();
    private int _uploadParallelism = 4;

    // Raw log upload fields
    private List<IBrowserFile> _selectedRawFiles = new();
    private bool _isUploadingRaw;
    private RawLogUploadResponse? _rawUploadResult;
    private RawUploadProgress? _rawUploadProgress;
    private QueueStatusResponse? _queueStatus;
    private bool _isLoadingQueue;

    // Server directory scan fields
    private string _rawSourceDirectory = string.Empty;
    private bool _scanRecursively = true;
    private bool _isScanningDirectory;
    private DirectoryScanResult? _directoryScanResult;

    // Directory import fields
    private string _sourceDirectory = string.Empty;
    private string? _completedDirectory;
    private string? _failedDirectory;
    private int _parallelism = 8;

    protected override async Task OnInitializedAsync()
    {
        await RefreshQueueStatus();
    }

    private async Task PostSessionSummary()
    {
        _postingSession = true;
        try
        {
            var response = await Http.PostAsync("api/admin/discord/post-session-summary", null);
            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add("Session summary queued for Discord!", Severity.Success);
            }
            else
            {
                Snackbar.Add("Failed to queue session summary", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            _postingSession = false;
        }
    }

    private void OnRawFilesSelected(IReadOnlyList<IBrowserFile> files)
    {
        _selectedRawFiles = files.ToList();
        _rawUploadResult = null;
    }

    private async Task UploadRawFilesBatched()
    {
        if (_selectedRawFiles.Count == 0) return;

        _isUploadingRaw = true;
        _rawUploadResult = null;

        const int batchSize = 10; // Upload 10 files at a time
        var totalFiles = _selectedRawFiles.Count;
        var totalBatches = (int)Math.Ceiling((double)totalFiles / batchSize);
        var allErrors = new List<string>();
        var totalAccepted = 0;
        var totalRejected = 0;

        _rawUploadProgress = new RawUploadProgress(0, totalFiles, 0, totalBatches, 0);
        StateHasChanged();

        try
        {
            for (int batchIndex = 0; batchIndex < totalBatches; batchIndex++)
            {
                var batch = _selectedRawFiles
                    .Skip(batchIndex * batchSize)
                    .Take(batchSize)
                    .ToList();

                _rawUploadProgress = new RawUploadProgress(
                    batchIndex * batchSize,
                    totalFiles,
                    batchIndex + 1,
                    totalBatches,
                    (double)(batchIndex * batchSize) / totalFiles * 100
                );
                StateHasChanged();

                try
                {
                    using var content = new MultipartFormDataContent();

                    foreach (var file in batch)
                    {
                        var stream = file.OpenReadStream(maxAllowedSize: 50_000_000);
                        var streamContent = new StreamContent(stream);
                        content.Add(streamContent, "files", file.Name);
                    }

                    var response = await Http.PostAsync("api/logs/upload", content);

                    if (response.IsSuccessStatusCode)
                    {
                        var result = await response.Content.ReadFromJsonAsync<RawLogUploadResponse>();
                        if (result != null)
                        {
                            totalAccepted += result.Accepted;
                            totalRejected += result.Rejected;
                            allErrors.AddRange(result.Errors);
                        }
                    }
                    else
                    {
                        var error = await response.Content.ReadAsStringAsync();
                        totalRejected += batch.Count;
                        allErrors.Add($"Batch {batchIndex + 1} failed: {error}");
                    }
                }
                catch (Exception ex)
                {
                    totalRejected += batch.Count;
                    allErrors.Add($"Batch {batchIndex + 1} error: {ex.Message}");
                }
            }

            _rawUploadResult = new RawLogUploadResponse(totalAccepted, totalRejected, allErrors);
            await RefreshQueueStatus();
        }
        finally
        {
            _isUploadingRaw = false;
            _rawUploadProgress = null;
            _selectedRawFiles.Clear();
            StateHasChanged();
        }
    }

    private async Task ScanServerDirectory()
    {
        if (string.IsNullOrWhiteSpace(_rawSourceDirectory)) return;

        _isScanningDirectory = true;
        _directoryScanResult = null;
        StateHasChanged();

        try
        {
            var request = new DirectoryScanRequest
            {
                SourceDirectory = _rawSourceDirectory,
                Recursive = _scanRecursively
            };

            var response = await Http.PostAsJsonAsync("api/logs/scan-directory", request);

            if (response.IsSuccessStatusCode)
            {
                _directoryScanResult = await response.Content.ReadFromJsonAsync<DirectoryScanResult>();
                await RefreshQueueStatus();
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                _directoryScanResult = new DirectoryScanResult(0, 0, 0, 1, $"Server error: {error}");
            }
        }
        catch (Exception ex)
        {
            _directoryScanResult = new DirectoryScanResult(0, 0, 0, 1, ex.Message);
        }
        finally
        {
            _isScanningDirectory = false;
            StateHasChanged();
        }
    }

    private async Task RefreshQueueStatus()
    {
        _isLoadingQueue = true;
        StateHasChanged();

        try
        {
            _queueStatus = await Http.GetFromJsonAsync<QueueStatusResponse>("api/logs/queue/status");
        }
        catch
        {
            _queueStatus = new QueueStatusResponse(0, 0, 0, new List<string>(), new List<string>());
        }
        finally
        {
            _isLoadingQueue = false;
            StateHasChanged();
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        return $"{bytes / 1024.0 / 1024.0:F1} MB";
    }

    private void OnFilesSelected(IReadOnlyList<IBrowserFile> files)
    {
        _selectedFiles = files.ToList();
        _fileProgress.Clear();
        _uploadResults.Clear();
    }

    private async Task UploadFilesParallel()
    {
        if (_selectedFiles.Count == 0) return;

        _isUploading = true;
        _uploadResults.Clear();
        _fileProgress = _selectedFiles.ToDictionary(
            f => f.Name,
            f => new FileUploadProgress { Status = UploadStatus.Pending }
        );
        StateHasChanged();

        try
        {
            using var semaphore = new SemaphoreSlim(_uploadParallelism);
            var tasks = _selectedFiles.Select(file => UploadSingleFileAsync(file, semaphore)).ToList();
            await Task.WhenAll(tasks);
        }
        finally
        {
            _isUploading = false;
            _selectedFiles.Clear();
            StateHasChanged();
        }
    }

    private async Task UploadSingleFileAsync(IBrowserFile file, SemaphoreSlim semaphore)
    {
        await semaphore.WaitAsync();

        try
        {
            // Update status to uploading
            _fileProgress[file.Name] = new FileUploadProgress { Status = UploadStatus.Uploading };
            await InvokeAsync(StateHasChanged);

            using var content = new MultipartFormDataContent();
            var stream = file.OpenReadStream(maxAllowedSize: 50_000_000);
            var streamContent = new StreamContent(stream);
            content.Add(streamContent, "files", file.Name);

            var response = await Http.PostAsync("api/admin/import/upload", content);

            if (response.IsSuccessStatusCode)
            {
                var results = await response.Content.ReadFromJsonAsync<List<ImportResult>>() ?? new();
                var result = results.FirstOrDefault();

                if (result != null)
                {
                    _fileProgress[file.Name] = new FileUploadProgress
                    {
                        Status = result.Success ? UploadStatus.Completed : UploadStatus.Failed,
                        Error = result.Error,
                        WasDuplicate = result.WasDuplicate,
                        BossName = result.BossName
                    };
                    _uploadResults.Add(result);
                }
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                _fileProgress[file.Name] = new FileUploadProgress
                {
                    Status = UploadStatus.Failed,
                    Error = $"Server error: {error}"
                };
                _uploadResults.Add(new ImportResult(false, null, file.Name, null, $"Server error: {error}", false));
            }
        }
        catch (Exception ex)
        {
            _fileProgress[file.Name] = new FileUploadProgress
            {
                Status = UploadStatus.Failed,
                Error = ex.Message
            };
            _uploadResults.Add(new ImportResult(false, null, file.Name, null, $"Error: {ex.Message}", false));
        }
        finally
        {
            semaphore.Release();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task StartDirectoryImport()
    {
        if (string.IsNullOrWhiteSpace(_sourceDirectory)) return;

        _isImporting = true;
        _bulkResult = null;
        StateHasChanged();

        try
        {
            var request = new DirectoryImportRequest
            {
                SourceDirectory = _sourceDirectory,
                CompletedDirectory = string.IsNullOrWhiteSpace(_completedDirectory) ? null : _completedDirectory,
                FailedDirectory = string.IsNullOrWhiteSpace(_failedDirectory) ? null : _failedDirectory,
                MaxParallelism = _parallelism
            };

            var response = await Http.PostAsJsonAsync("api/admin/import/directory", request);

            if (response.IsSuccessStatusCode)
            {
                _bulkResult = await response.Content.ReadFromJsonAsync<BulkImportResult>();
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                _bulkResult = new BulkImportResult(0, 0, 0, 1, TimeSpan.Zero, new List<ImportResult>
                {
                    new ImportResult(false, null, "Directory Import", null, $"Server error: {error}", false)
                });
            }
        }
        catch (Exception ex)
        {
            _bulkResult = new BulkImportResult(0, 0, 0, 1, TimeSpan.Zero, new List<ImportResult>
            {
                new ImportResult(false, null, "Directory Import", null, $"Error: {ex.Message}", false)
            });
        }
        finally
        {
            _isImporting = false;
            StateHasChanged();
        }
    }

    // DTOs matching the server models
    public record ImportResult(
        bool Success,
        Guid? EncounterId,
        string FileName,
        string? BossName,
        string? Error,
        bool WasDuplicate
    );

    public record BulkImportResult(
        int TotalFiles,
        int Imported,
        int Duplicates,
        int Failed,
        TimeSpan Duration,
        List<ImportResult> Results
    );

    public record DirectoryImportRequest
    {
        public required string SourceDirectory { get; init; }
        public string? CompletedDirectory { get; init; }
        public string? FailedDirectory { get; init; }
        public int MaxParallelism { get; init; } = 8;
    }

    public enum UploadStatus
    {
        Pending,
        Uploading,
        Completed,
        Failed
    }

    public class FileUploadProgress
    {
        public UploadStatus Status { get; set; }
        public string? Error { get; set; }
        public bool WasDuplicate { get; set; }
        public string? BossName { get; set; }
    }

    // Raw log upload DTOs
    public record RawLogUploadResponse(
        int Accepted,
        int Rejected,
        List<string> Errors
    );

    public record QueueStatusResponse(
        int PendingCount,
        int ProcessingCount,
        int FailedCount,
        List<string> PendingFiles,
        List<string> ProcessingFiles
    );

    public record RawUploadProgress(
        int FilesUploaded,
        int TotalFiles,
        int CurrentBatch,
        int TotalBatches,
        double PercentComplete
    );

    public record DirectoryScanRequest
    {
        public required string SourceDirectory { get; init; }
        public bool Recursive { get; init; } = true;
    }

    public record DirectoryScanResult(
        int Found,
        int Queued,
        int Skipped,
        int Failed,
        string? Error = null
    );
}
